#!/usr/bin/env python
"""
check_refresh_time_of_token.py: Checks the validity and time until expiry
for a given Direct Line conversation ID and conversation token.
Attempts to refresh the token if the initial check fails.

Requires:
    python-dotenv
    httpx>=0.25
    directline_client (autogenerated client)
    typer (for CLI arguments)
    rich (for better console output)
"""

import asyncio
import logging
import os
from datetime import datetime, timedelta, timezone

import httpx
import typer  # Ensure typer is imported
from dotenv import load_dotenv
from rich.console import Console
from rich.logging import RichHandler
from rich.panel import Panel
from rich.table import Table

from directline_client import AuthenticatedClient
from directline_client.api.conversations import \
    conversations_reconnect_to_conversation
from directline_client.api.tokens import \
    tokens_refresh_token  # Import for refreshing
from directline_client.models import Conversation
from directline_client.types import UNSET

# --------------------------------------------------------------------------- #
#                           CONFIGURATION & LOGGING                           #
# --------------------------------------------------------------------------- #
load_dotenv()
BASE_URL = "https://directline.botframework.com"

logging.basicConfig(
    level="INFO",
    format="%(message)s",
    datefmt="[%X]",
    handlers=[RichHandler(rich_tracebacks=True, console=Console(stderr=True))]
)
log = logging.getLogger("directline.token_check")
console = Console()

# Initialize Typer app at the global scope
app = typer.Typer(
    help="Check Direct Line Token Expiry Information & Attempt Refresh.")


# --------------------------------------------------------------------------- #
#                               HELPER FUNCTIONS                              #
# --------------------------------------------------------------------------- #

async def get_conversation_details(
    client: AuthenticatedClient, conversation_id: str, operation_desc: str = "get details"
) -> Conversation | None:
    """Fetches conversation details."""
    try:
        log.info(
            f"Attempting to {operation_desc} for conversation ID: {conversation_id}"
        )
        conversation_info: Conversation | None = await conversations_reconnect_to_conversation.asyncio(
            client=client,
            conversation_id=conversation_id,
        )
        return conversation_info
    except httpx.HTTPStatusError as e:
        if e.response.status_code == 401:
            log.warning(
                f"HTTP 401 Unauthorized while trying to {operation_desc} for conversation {conversation_id}. Token may be expired."
            )
        elif e.response.status_code == 403:
            log.warning(
                f"HTTP 403 Forbidden while trying to {operation_desc} for conversation {conversation_id}. Token may be invalid or permissions issue."
            )
        elif e.response.status_code == 404:
            log.error(
                f"HTTP 404 Not Found: Conversation ID {conversation_id} not found while trying to {operation_desc}."
            )
        else:
            log.error(
                f"HTTP Error during '{operation_desc}': {e.response.status_code} - {e.response.text}"
            )
        return None
    except Exception as e:
        log.error(
            f"An unexpected error occurred during '{operation_desc}': {e}", exc_info=True)
        return None


async def attempt_token_refresh(
    client: AuthenticatedClient  # Client should be initialized with the token to refresh
) -> Conversation | None:
    """Attempts to refresh the token using the provided client."""
    try:
        log.info("Attempting to refresh the provided token...")
        refreshed_conversation: Conversation | None = await tokens_refresh_token.asyncio(
            client=client
        )
        if refreshed_conversation and refreshed_conversation.token is not UNSET:
            log.info(
                f"[green]Token refreshed successfully![/green] New token prefix: {str(refreshed_conversation.token)[:15]}...")
            return refreshed_conversation
        else:
            log.warning(
                "Token refresh API call succeeded but did not return a new token or conversation details.")
            return None
    except httpx.HTTPStatusError as e:
        log.error(
            f"HTTP Error during token refresh: {e.response.status_code} - {e.response.text}")
        return None
    except Exception as e:
        log.error(
            f"An unexpected error occurred during token refresh: {e}", exc_info=True)
        return None


def display_token_status(
    conversation_details: Conversation,
    original_token_provided: str,
    was_refreshed_in_script: bool = False,
    newly_refreshed_token_value: str | None = None
):
    """Displays the token status in a table and summary."""
    table = Table(title="Token Status")
    table.add_column("Property", style="dim", width=30)
    table.add_column("Value")

    table.add_row("Conversation ID", str(conversation_details.conversation_id))

    current_display_token = newly_refreshed_token_value or original_token_provided
    api_returned_token = conversation_details.token

    if was_refreshed_in_script and newly_refreshed_token_value:
        table.add_row("[cyan]Token Refreshed by Script[/cyan]", "True")
        table.add_row("Original Token (prefix)",
                      f"{original_token_provided[:15]}...")
        table.add_row("New Token (prefix)",
                      f"{newly_refreshed_token_value[:15]}...")
    elif api_returned_token is not UNSET and api_returned_token != original_token_provided and api_returned_token != current_display_token:
        table.add_row(
            "[yellow]Token Refreshed by API (on get details)[/yellow]", "True")
        table.add_row("Original/Provided Token (prefix)",
                      f"{original_token_provided[:15]}...")
        if current_display_token != original_token_provided:
            table.add_row("Script-Refreshed Token (prefix)",
                          f"{current_display_token[:15]}...")
        table.add_row("API GET Details Returned Token (prefix)",
                      f"{str(api_returned_token)[:15]}...")
        current_display_token = str(api_returned_token)
    else:
        table.add_row("Token Refreshed (this session)", "False")
        table.add_row("Current Token (prefix)",
                      f"{current_display_token[:15]}...")

    expires_in_seconds = conversation_details.expires_in
    if expires_in_seconds is not UNSET and isinstance(expires_in_seconds, int):
        table.add_row("Expires In (seconds)",
                      f"[green]{expires_in_seconds}[/green]")
        now_utc = datetime.now(timezone.utc)
        expiry_time_utc = now_utc + timedelta(seconds=expires_in_seconds)
        time_left = expiry_time_utc - now_utc
        table.add_row("Expected Expiry (UTC)", str(
            expiry_time_utc.strftime('%Y-%m-%d %H:%M:%S %Z')))
        table.add_row("Time Left", str(time_left).split('.')[0])

        if expires_in_seconds < 0:
            panel_content = "Token appears to be [bold red]EXPIRED[/bold red] (negative 'expires_in')."
        elif expires_in_seconds < 300:
            panel_content = f"Token is [bold yellow]VALID[/bold yellow], but expires in less than 5 minutes ({time_left})."
        else:
            panel_content = f"Token is [bold green]VALID[/bold green]. Time until expiry: {time_left}."
    else:
        table.add_row("Expires In (seconds)", "[red]Unknown[/red]")
        panel_content = "Token status is [bold yellow]UNCERTAIN[/bold yellow] (could not determine 'expires_in')."

    console.print(table)
    console.print(
        Panel(panel_content, title="[b]Summary[/b]", border_style="blue"))


# --------------------------------------------------------------------------- #
#                               MAIN COMMAND                                  #
# --------------------------------------------------------------------------- #
# The @app.command() decorator now correctly finds 'app' defined globally above
@app.command()
def check(
    conversation_id: str = typer.Option(
        ..., help="The Direct Line conversation ID.", prompt="Enter Conversation ID"
    ),
    token: str = typer.Option(
        ...,
        help="The Direct Line conversation token.",
        prompt="Enter Conversation Token (will be hidden)",
        hide_input=True,
    ),
    base_url: str = typer.Option(
        BASE_URL, help="The base URL for the Direct Line API."
    ),
):
    """
    Checks the validity and expiry time of a Direct Line conversation token.
    Attempts to refresh the token if the initial check fails.
    """
    # No need to define 'app = typer.Typer(...)' inside this function anymore
    console.rule(
        "[bold cyan]Direct Line Token Check & Refresh Attempt[/bold cyan]")
    log.info(f"Using Base URL: {base_url}")
    log.info(f"Checking token for Conversation ID: {conversation_id}")
    log.info(f"Provided Token (prefix): {token[:15]}...")

    async def main_async():
        current_token_to_use = token
        was_refreshed_in_script = False
        newly_refreshed_token_value = None

        async with AuthenticatedClient(
            base_url=base_url, token=current_token_to_use, raise_on_unexpected_status=False
        ) as client:
            log.info(f"\n--- Initial Check ---")
            conversation_details = await get_conversation_details(
                client, conversation_id, operation_desc="get details (initial check)"
            )

        if conversation_details:
            display_token_status(conversation_details, token)
        else:
            log.warning(
                "Initial check failed. Attempting to refresh the token..."
            )
            async with AuthenticatedClient(
                base_url=base_url, token=token, raise_on_unexpected_status=False
            ) as client_for_refresh:
                log.info(f"\n--- Refresh Attempt ---")
                refreshed_conv_object = await attempt_token_refresh(client_for_refresh)

            if refreshed_conv_object and refreshed_conv_object.token is not UNSET:
                was_refreshed_in_script = True
                newly_refreshed_token_value = str(refreshed_conv_object.token)
                current_token_to_use = newly_refreshed_token_value

                async with AuthenticatedClient(
                    base_url=base_url, token=current_token_to_use, raise_on_unexpected_status=False
                ) as client_with_new_token:
                    log.info(f"\n--- Post-Refresh Check ---")
                    conversation_details_after_refresh = await get_conversation_details(
                        client_with_new_token, conversation_id, operation_desc="get details (post-refresh)"
                    )

                if conversation_details_after_refresh:
                    if refreshed_conv_object.conversation_id is UNSET or refreshed_conv_object.conversation_id == "":
                        refreshed_conv_object.conversation_id = conversation_details_after_refresh.conversation_id

                    display_token_status(
                        refreshed_conv_object,
                        token,
                        was_refreshed_in_script=True,
                        newly_refreshed_token_value=newly_refreshed_token_value
                    )
                else:
                    log.error(
                        f"Token refresh seemed successful (got new token), but failed to get conversation details with it for {conversation_id}."
                    )
                    console.print(Panel(
                        "Token refresh appeared to succeed, but could not subsequently verify it against the conversation.",
                        title="[b orange_red1]Refresh Verification Failed[/b orange_red1]",
                        border_style="orange_red1"
                    ))
            else:
                log.error(
                    "Token refresh failed or did not yield a new token."
                )
                console.print(Panel(
                    "Could not retrieve token status, and token refresh attempt also failed.",
                    title="[b red]Error & Refresh Failed[/b red]",
                    border_style="red"
                ))

    asyncio.run(main_async())


if __name__ == "__main__":
    app()
