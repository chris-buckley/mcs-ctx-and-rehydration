# coding: utf-8

"""
    Microsoft Bot Connector API - v3.0

    The Bot Connector REST API allows your bot to send and receive messages to channels configured in the  [Bot Framework Developer Portal](https://dev.botframework.com). The Connector service uses industry-standard REST  and JSON over HTTPS.    Client libraries for this REST API are available. See below for a list.    Many bots will use both the Bot Connector REST API and the associated [Bot State REST API](/en-us/restapi/state). The  Bot State REST API allows a bot to store and retrieve state associated with users and conversations.    Authentication for both the Bot Connector and Bot State REST APIs is accomplished with JWT Bearer tokens, and is  described in detail in the [Connector Authentication](/en-us/restapi/authentication) document.    # Client Libraries for the Bot Connector REST API    * [Bot Builder for C#](/en-us/csharp/builder/sdkreference/)  * [Bot Builder for Node.js](/en-us/node/builder/overview/)  * Generate your own from the [Connector API Swagger file](https://raw.githubusercontent.com/Microsoft/BotBuilder/master/CSharp/Library/Microsoft.Bot.Connector.Shared/Swagger/ConnectorAPI.json)    Â© 2016 Microsoft

    The version of the OpenAPI document: v3
    Contact: botframework@microsoft.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from bot_connector.models.activity_importance import ActivityImportance
from bot_connector.models.activity_types import ActivityTypes
from bot_connector.models.attachment import Attachment
from bot_connector.models.attachment_layout_types import AttachmentLayoutTypes
from bot_connector.models.channel_account import ChannelAccount
from bot_connector.models.conversation_account import ConversationAccount
from bot_connector.models.conversation_reference import ConversationReference
from bot_connector.models.delivery_modes import DeliveryModes
from bot_connector.models.end_of_conversation_codes import EndOfConversationCodes
from bot_connector.models.entity import Entity
from bot_connector.models.input_hints import InputHints
from bot_connector.models.message_reaction import MessageReaction
from bot_connector.models.semantic_action import SemanticAction
from bot_connector.models.suggested_actions import SuggestedActions
from bot_connector.models.text_format_types import TextFormatTypes
from bot_connector.models.text_highlight import TextHighlight
from typing import Optional, Set
from typing_extensions import Self

class Activity(BaseModel):
    """
    An Activity is the basic communication type for the Bot Framework 3.0 protocol.
    """ # noqa: E501
    type: Optional[ActivityTypes] = None
    id: Optional[StrictStr] = Field(default=None, description="Contains an ID that uniquely identifies the activity on the channel.")
    timestamp: Optional[datetime] = Field(default=None, description="Contains the date and time that the message was sent, in UTC, expressed in ISO-8601 format.")
    local_timestamp: Optional[datetime] = Field(default=None, description="Contains the local date and time of the message, expressed in ISO-8601 format.  For example, 2016-09-23T13:07:49.4714686-07:00.", alias="localTimestamp")
    local_timezone: Optional[StrictStr] = Field(default=None, description="Contains the name of the local timezone of the message, expressed in IANA Time Zone database format.  For example, America/Los_Angeles.", alias="localTimezone")
    caller_id: Optional[StrictStr] = Field(default=None, description="A string containing an IRI identifying the caller of a bot. This field is not intended to be transmitted  over the wire, but is instead populated by bots and clients based on cryptographically verifiable data  that asserts the identity of the callers (e.g. tokens).", alias="callerId")
    service_url: Optional[StrictStr] = Field(default=None, description="Contains the URL that specifies the channel's service endpoint. Set by the channel.", alias="serviceUrl")
    channel_id: Optional[StrictStr] = Field(default=None, description="Contains an ID that uniquely identifies the channel. Set by the channel.", alias="channelId")
    var_from: Optional[ChannelAccount] = Field(default=None, alias="from")
    conversation: Optional[ConversationAccount] = None
    recipient: Optional[ChannelAccount] = None
    text_format: Optional[TextFormatTypes] = Field(default=None, alias="textFormat")
    attachment_layout: Optional[AttachmentLayoutTypes] = Field(default=None, alias="attachmentLayout")
    members_added: Optional[List[ChannelAccount]] = Field(default=None, description="The collection of members added to the conversation.", alias="membersAdded")
    members_removed: Optional[List[ChannelAccount]] = Field(default=None, description="The collection of members removed from the conversation.", alias="membersRemoved")
    reactions_added: Optional[List[MessageReaction]] = Field(default=None, description="The collection of reactions added to the conversation.", alias="reactionsAdded")
    reactions_removed: Optional[List[MessageReaction]] = Field(default=None, description="The collection of reactions removed from the conversation.", alias="reactionsRemoved")
    topic_name: Optional[StrictStr] = Field(default=None, description="The updated topic name of the conversation.", alias="topicName")
    history_disclosed: Optional[StrictBool] = Field(default=None, description="Indicates whether the prior history of the channel is disclosed.", alias="historyDisclosed")
    locale: Optional[StrictStr] = Field(default=None, description="A locale name for the contents of the text field.  The locale name is a combination of an ISO 639 two- or three-letter culture code associated with a language  and an ISO 3166 two-letter subculture code associated with a country or region.  The locale name can also correspond to a valid BCP-47 language tag.")
    text: Optional[StrictStr] = Field(default=None, description="The text content of the message.")
    speak: Optional[StrictStr] = Field(default=None, description="The text to speak.")
    input_hint: Optional[InputHints] = Field(default=None, alias="inputHint")
    summary: Optional[StrictStr] = Field(default=None, description="The text to display if the channel cannot render cards.")
    suggested_actions: Optional[SuggestedActions] = Field(default=None, alias="suggestedActions")
    attachments: Optional[List[Attachment]] = Field(default=None, description="Attachments")
    entities: Optional[List[Entity]] = Field(default=None, description="Represents the entities that were mentioned in the message.")
    channel_data: Optional[Dict[str, Any]] = Field(default=None, description="Contains channel-specific content.", alias="channelData")
    action: Optional[StrictStr] = Field(default=None, description="Indicates whether the recipient of a contactRelationUpdate was added or removed from the sender's contact list.")
    reply_to_id: Optional[StrictStr] = Field(default=None, description="Contains the ID of the message to which this message is a reply.", alias="replyToId")
    label: Optional[StrictStr] = Field(default=None, description="A descriptive label for the activity.")
    value_type: Optional[StrictStr] = Field(default=None, description="The type of the activity's value object.", alias="valueType")
    value: Optional[Dict[str, Any]] = Field(default=None, description="A value that is associated with the activity.")
    name: Optional[StrictStr] = Field(default=None, description="The name of the operation associated with an invoke or event activity.")
    relates_to: Optional[ConversationReference] = Field(default=None, alias="relatesTo")
    code: Optional[EndOfConversationCodes] = None
    expiration: Optional[datetime] = Field(default=None, description="The time at which the activity should be considered to be \"expired\" and should not be presented to the recipient.")
    importance: Optional[ActivityImportance] = None
    delivery_mode: Optional[DeliveryModes] = Field(default=None, alias="deliveryMode")
    listen_for: Optional[List[StrictStr]] = Field(default=None, description="List of phrases and references that speech and language priming systems should listen for", alias="listenFor")
    text_highlights: Optional[List[TextHighlight]] = Field(default=None, description="The collection of text fragments to highlight when the activity contains a ReplyToId value.", alias="textHighlights")
    semantic_action: Optional[SemanticAction] = Field(default=None, alias="semanticAction")
    __properties: ClassVar[List[str]] = ["type", "id", "timestamp", "localTimestamp", "localTimezone", "callerId", "serviceUrl", "channelId", "from", "conversation", "recipient", "textFormat", "attachmentLayout", "membersAdded", "membersRemoved", "reactionsAdded", "reactionsRemoved", "topicName", "historyDisclosed", "locale", "text", "speak", "inputHint", "summary", "suggestedActions", "attachments", "entities", "channelData", "action", "replyToId", "label", "valueType", "value", "name", "relatesTo", "code", "expiration", "importance", "deliveryMode", "listenFor", "textHighlights", "semanticAction"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Activity from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of var_from
        if self.var_from:
            _dict['from'] = self.var_from.to_dict()
        # override the default output from pydantic by calling `to_dict()` of conversation
        if self.conversation:
            _dict['conversation'] = self.conversation.to_dict()
        # override the default output from pydantic by calling `to_dict()` of recipient
        if self.recipient:
            _dict['recipient'] = self.recipient.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in members_added (list)
        _items = []
        if self.members_added:
            for _item_members_added in self.members_added:
                if _item_members_added:
                    _items.append(_item_members_added.to_dict())
            _dict['membersAdded'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in members_removed (list)
        _items = []
        if self.members_removed:
            for _item_members_removed in self.members_removed:
                if _item_members_removed:
                    _items.append(_item_members_removed.to_dict())
            _dict['membersRemoved'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in reactions_added (list)
        _items = []
        if self.reactions_added:
            for _item_reactions_added in self.reactions_added:
                if _item_reactions_added:
                    _items.append(_item_reactions_added.to_dict())
            _dict['reactionsAdded'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in reactions_removed (list)
        _items = []
        if self.reactions_removed:
            for _item_reactions_removed in self.reactions_removed:
                if _item_reactions_removed:
                    _items.append(_item_reactions_removed.to_dict())
            _dict['reactionsRemoved'] = _items
        # override the default output from pydantic by calling `to_dict()` of suggested_actions
        if self.suggested_actions:
            _dict['suggestedActions'] = self.suggested_actions.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in attachments (list)
        _items = []
        if self.attachments:
            for _item_attachments in self.attachments:
                if _item_attachments:
                    _items.append(_item_attachments.to_dict())
            _dict['attachments'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in entities (list)
        _items = []
        if self.entities:
            for _item_entities in self.entities:
                if _item_entities:
                    _items.append(_item_entities.to_dict())
            _dict['entities'] = _items
        # override the default output from pydantic by calling `to_dict()` of relates_to
        if self.relates_to:
            _dict['relatesTo'] = self.relates_to.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in text_highlights (list)
        _items = []
        if self.text_highlights:
            for _item_text_highlights in self.text_highlights:
                if _item_text_highlights:
                    _items.append(_item_text_highlights.to_dict())
            _dict['textHighlights'] = _items
        # override the default output from pydantic by calling `to_dict()` of semantic_action
        if self.semantic_action:
            _dict['semanticAction'] = self.semantic_action.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Activity from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "type": obj.get("type"),
            "id": obj.get("id"),
            "timestamp": obj.get("timestamp"),
            "localTimestamp": obj.get("localTimestamp"),
            "localTimezone": obj.get("localTimezone"),
            "callerId": obj.get("callerId"),
            "serviceUrl": obj.get("serviceUrl"),
            "channelId": obj.get("channelId"),
            "from": ChannelAccount.from_dict(obj["from"]) if obj.get("from") is not None else None,
            "conversation": ConversationAccount.from_dict(obj["conversation"]) if obj.get("conversation") is not None else None,
            "recipient": ChannelAccount.from_dict(obj["recipient"]) if obj.get("recipient") is not None else None,
            "textFormat": obj.get("textFormat"),
            "attachmentLayout": obj.get("attachmentLayout"),
            "membersAdded": [ChannelAccount.from_dict(_item) for _item in obj["membersAdded"]] if obj.get("membersAdded") is not None else None,
            "membersRemoved": [ChannelAccount.from_dict(_item) for _item in obj["membersRemoved"]] if obj.get("membersRemoved") is not None else None,
            "reactionsAdded": [MessageReaction.from_dict(_item) for _item in obj["reactionsAdded"]] if obj.get("reactionsAdded") is not None else None,
            "reactionsRemoved": [MessageReaction.from_dict(_item) for _item in obj["reactionsRemoved"]] if obj.get("reactionsRemoved") is not None else None,
            "topicName": obj.get("topicName"),
            "historyDisclosed": obj.get("historyDisclosed"),
            "locale": obj.get("locale"),
            "text": obj.get("text"),
            "speak": obj.get("speak"),
            "inputHint": obj.get("inputHint"),
            "summary": obj.get("summary"),
            "suggestedActions": SuggestedActions.from_dict(obj["suggestedActions"]) if obj.get("suggestedActions") is not None else None,
            "attachments": [Attachment.from_dict(_item) for _item in obj["attachments"]] if obj.get("attachments") is not None else None,
            "entities": [Entity.from_dict(_item) for _item in obj["entities"]] if obj.get("entities") is not None else None,
            "channelData": obj.get("channelData"),
            "action": obj.get("action"),
            "replyToId": obj.get("replyToId"),
            "label": obj.get("label"),
            "valueType": obj.get("valueType"),
            "value": obj.get("value"),
            "name": obj.get("name"),
            "relatesTo": ConversationReference.from_dict(obj["relatesTo"]) if obj.get("relatesTo") is not None else None,
            "code": obj.get("code"),
            "expiration": obj.get("expiration"),
            "importance": obj.get("importance"),
            "deliveryMode": obj.get("deliveryMode"),
            "listenFor": obj.get("listenFor"),
            "textHighlights": [TextHighlight.from_dict(_item) for _item in obj["textHighlights"]] if obj.get("textHighlights") is not None else None,
            "semanticAction": SemanticAction.from_dict(obj["semanticAction"]) if obj.get("semanticAction") is not None else None
        })
        return _obj


